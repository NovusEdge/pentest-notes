## General Useful Utilities

| Utility                                            | Purpose                   | Example                                                |
| -------------------------------------------------- | ------------------------- | ------------------------------------------------------ |
| `wget`                                             | To download file(s)       | `wget -O OUTPUT_PATH REMOTE_RESOURCE_URL`              |
| [[Linux Fundamentals 2#Secure SHell (SSH)\|`ssh`]] | Secure SHell Access       | `ssh user@REMOTE`                                      |
| `scp`                                              | Transfer files over `ssh` | See examples in [[Linux Fundamentals 2]]               |
| `python3`                                          | Endless possibilities     | `python3 -m http.server PORT` -> Serve files over http |

## Processes and Jobs

A process, in the simplest terms, is just some program running on the system.
A **job** is a program managed by the shell. A job may consist of one or more _processes_. 
- `Ctrl-C`: Kill the process running in the foreground by sending the signal `SIGINT`
- `Ctrl-Z`: Suspend the process running in the foreground by sending the signal `SIGTSTP`
- [_`jobs`_](https://www.man7.org/linux/man-pages/man1/jobs.1p.html): Display a list of the jobs with their status
- [_`fg`_](https://www.man7.org/linux/man-pages/man1/fg.1p.html): Move a background job into the foreground
- [_`bg`_](https://www.man7.org/linux/man-pages/man1/bg.1p.html): Resume suspended jobs by running them as background jobs

##### SIGHUP Signal
- **SIGHUP** stands for "Signal Hang UP".
- It's a signal sent to a process when its controlling terminal is closed. This often happens when a user logs out of a shell session.
- By default, the process that receives this signal will terminate. This is because, historically, the loss of a connection to a terminal (or "hang up") meant the process couldn't continue.
- However, many daemons and long-running processes are designed to handle `SIGHUP` differently, often to reload their configuration files.

##### The `nohup` Command
- **`nohup`** stands for "No Hang UP".
- It's a command used to run another command, telling it to ignore the `SIGHUP` signal. This allows the command to continue running even after the user has logged out.
- For example, `nohup ./my_script &` will start `my_script` in the background, and `my_script` will not terminate when the user logs out or closes the terminal.
- `nohup` is often used for long-running processes in scripts and automation.

##### The `disown` Command
The `disown` command in Linux is used in conjunction with job control in shell environments like Bash. It removes a job from the shell's job table, which effectively means the shell will no longer manage or track that process. This is particularly useful in the context of long-running processes or tasks initiated from a terminal.

Here's a brief explanation of what `disown` does:
1. **Detaches a Process from the Terminal:** When you run a process in the background (using `&` at the end of a command), it's still attached to the terminal. If the terminal is closed, the process might be terminated. Using `disown` on a background process ensures that even if the terminal is closed, the process continues to run.
2. **Prevents the Process from Receiving a SIGHUP:** Normally, when a terminal session ends, it sends a SIGHUP signal to all jobs associated with that session, which typically causes them to terminate. `disown` removes the job from the shell’s job list, so it won't receive the SIGHUP signal when the session ends.
3. **Useful for Long-Running Background Jobs:** It's commonly used for long-running tasks that you want to continue running even after logging out of the shell or closing the terminal.

For example, if you start a process in the background:
```bash
./long_running_script &
```
And then use `disown`:
```bash
disown %1
```
This will remove the `long_running_script` from the shell’s job list, and it will continue to run even if you close the terminal.
`disown` is a shell built-in command and its behavior might slightly vary between different shells (like `bash`, `zsh`, etc.).

### `cron` Jobs and `crontab`

| Element | Linux Name | Meaning                                                                                                                                               |
| ------- | ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| Daemon  | `crond`    | These are Linux background system processes.                                                                         |
| Table   | `crontab`  | You write rows to this table when entering a `crontab` command. Each ‘\*’ asterisk represents a segment of time and a corresponding column in each row. |
| Job     | `cron` Job   | The specific task to be performed described in a row, paired with its designated time id                                                              |


##### What's a _Daemon_?
A _daemon_ in Linux or Unix-like systems is a background process that runs independently of user interaction. Here's a simple explanation, including how it uses forking during system startup:

- **Daemon Basics:**
  - Runs in the background, performing specific tasks or waiting for specific events.
  - Does not have a controlling terminal.
  - Often starts when the system boots and runs until the system shuts down.

- **Forking Process:**
  - When the system starts, a daemon typically begins as a normal process.
  - It then "forks" itself, creating a child process.
  - The original process (parent) terminates.
  - The child process continues running in the background.
  - This forking allows the daemon to detach from the terminal and run independently.

- **Purpose and Use:**
  - Daemons handle various system-level tasks like scheduling (`cron`), printing (`cupsd`), managing network connections, and more.
  - They are essential for system and network management, running without user intervention.

#### `Crontab` Syntax
- `crontab` uses the entries stored in `/var/spool/cron/crontabs/` or `/var/spool/cron/`. 
- `/etc/cron.d` is the location for the system `cron` entries.
- `/lib/systemd/system/crontab.service` is the `systemd` `cron` service.
- The system-wide `cron` job entries can be found in `/etc/crontab`. 

Here's what the syntax looks like
```cron
+---------------- minute (0 - 59)
|  +------------- hour (0 - 23)
|  |  +---------- day of month (1 - 31)
|  |  |  +------- month (1 - 12)
|  |  |  |  +---- day of week (0 - 6) (Sunday=0 or 7)
|  |  |  |  |
*  *  *  *  *  command to be executed
```
An example of a `cron` job entry is:
```cron
30 7 * * 1 /usr/local/bin/backup.sh
```
- `30` - Minute: The cron job will run at 30 minutes past the hour.
- `7` - Hour: The job will run at 7 AM.
- `*` - Day of the Month: The asterisk here represents every day of the month.
- `*` - Month: The asterisk here represents every month.
- `1` - Day of the Week: The job will run on Monday (where Sunday = 0, Monday = 1, and so on).
- `/usr/local/bin/backup.sh` - This is the command or script that will be executed. In this case, it's a script located at `/usr/local/bin/backup.sh`.

So, this `cron` job will run the script `backup.sh` at 7:30 AM every Monday. 
```shell-session
user@system:~$ crontab -e
## Add the entry and exit
## Now verify the entry
user@system:~$ crontab -l
```

### Managing Processes
Commands like `top`/`htop`/`btm`(rust implementation of `htop`) can be used to have a look at and manage the running processes.

To kill a command, we can use the appropriately named `kill` command and the associated PID that we wish to kill. i.e., to kill _PID_ 1337, we'd use `kill 1337`.

Below are some of the signals that we can send to a process when it is killed:
- `SIGTERM` - Kill the process, but allow it to do some cleanup tasks beforehand
- `SIGKILL` - Kill the process - doesn't do any cleanup after the fact
- `SIGSTOP` - Stop/suspend a process

> [!info]  
> On many systems, `systemctl` allows us to interact and manage the `systemd` daemon and work with processes.

> [!info] 
> The `bg` and `fg` commands can be used to push processes into the background and the foreground.







